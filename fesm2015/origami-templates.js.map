{"version":3,"file":"origami-templates.js","sources":["ng://@codebakery/origami/templates/src/polymerHost.ts","ng://@codebakery/origami/templates/src/shim-template-append.ts","ng://@codebakery/origami/templates/src/template.directive.ts","ng://@codebakery/origami/templates/src/template.module.ts","ng://@codebakery/origami/templates/origami-templates.ts"],"sourcesContent":["import { InjectionToken, Provider, Type } from '@angular/core';\n\n/**\n * Token that represents the Polymer host that `<template>` elements should\n * refer to for Polymer data binding. The token will be provided when using\n * `polymerHost()`.\n */\nexport const POLYMER_HOST = new InjectionToken<any>('polymerHost');\n\n/**\n * Creates a `Provider` that connects a components' Polymer `<template>`\n * elements' data binding system to the host component instance.\n *\n * This enables the use of event, one-way, and two-way Polymer data binding\n * within a `<template>` that refers to the host Angular component's methods and\n * properties.\n *\n * @param componentType the component type whose instances should be provided\n *   as the Polymer host to the instance's `<template>` elements.\n */\nexport function polymerHost(componentType: Type<any>): Provider {\n  return {\n    provide: POLYMER_HOST,\n    useFactory: patchPolymerHost,\n    deps: [componentType]\n  };\n}\n\n/**\n * Patch a data host instance with methods that are expected by Polymer's\n * `TemplateStamp` mixin. These methods are used to set up data bindings, and\n * are normally provided when a Polymer element extends from `TemplateStamp`.\n *\n * Angular components do not extend this mixin, which is why we need to patch\n * the required methods. Instances will automatically be patched when using\n * `polymerHost()`.\n *\n * @param dataHost the host to patch\n * @returns the patched dataHost\n */\nexport function patchPolymerHost(dataHost: any): any {\n  // Add methods from TemplateStamp that templatize instances expect\n  if (!dataHost._addEventListenerToNode) {\n    dataHost._addEventListenerToNode = (\n      node: Node,\n      eventName: string,\n      handler: (e: Event) => void\n    ) => {\n      node.addEventListener(eventName, handler);\n    };\n  }\n\n  return dataHost;\n}\n","import { whenSet } from '@codebakery/origami/util';\n\ndeclare global {\n  interface Window {\n    HTMLTemplateElement: typeof HTMLTemplateElement;\n  }\n}\n\nlet shimPromise: Promise<void> | undefined;\n/**\n * Angular incorrectly adds `<template>` children to the element's child node\n * list instead of its content. This shim forces children appended to a\n * `<template>` to be added to its content instead.\n *\n * https://github.com/angular/angular/issues/15557\n *\n * @returns a Promise that resolves when the HTMLTemplateElement is shimmed\n */\nexport function shimHTMLTemplateAppend(): Promise<void> {\n  if (!shimPromise) {\n    const shim = () => {\n      // Angular's renderer will add children to a <template> instead of to its\n      // content. This shim will force any children added to a <template> to be\n      // added to its content instead.\n      // https://github.com/angular/angular/issues/15557\n      const nativeAppend = HTMLTemplateElement.prototype.appendChild;\n      HTMLTemplateElement.prototype.appendChild = function<T extends Node>(\n        childNode: T\n      ) {\n        if (this.content) {\n          return this.content.appendChild(childNode);\n        } else {\n          return <T>nativeAppend.apply(this, [childNode]);\n        }\n      };\n    };\n\n    shimPromise = new Promise(async resolve => {\n      await whenSet(window, 'HTMLTemplateElement');\n      shim();\n      resolve();\n    });\n  }\n\n  return shimPromise;\n}\n\n/**\n * Resets `shimHTMLTemplateAppend()` so that it will re-shim the class next\n * time it is called. This is primarily used for testing.\n */\nexport function resetShimHTMLTemplateAppend() {\n  shimPromise = undefined;\n}\n","import { Directive, ElementRef, Inject, Optional, NgZone } from '@angular/core';\nimport { whenSet, wrapAndDefineDescriptor } from '@codebakery/origami/util';\nimport { camelToDashCase } from '@polymer/polymer/lib/utils/case-map';\nimport { TemplateInfo } from '@polymer/polymer/interfaces';\nimport { POLYMER_HOST } from './polymerHost';\n\n/**\n * An HTMLTemplateElement that is processed by Polymer's templatizer.\n */\nexport interface PolymerTemplate extends HTMLTemplateElement {\n  /**\n   * Added by the `PropertyEffects` mixin to instruct templatize of the host\n   * for the template. Effects that are not part of the template instance will\n   * propagate to this host.\n   */\n  __dataHost?: any;\n  /**\n   * Template metadata generated from `TemplateStamp`.\n   */\n  _templateInfo?: TemplateInfo;\n  /**\n   * Host properties are defined as `_host_propName` by templatizer.\n   */\n  [hostProp: string]: any;\n}\n\n/**\n * This directive is attached to each `<template>` element. If a Polymer host\n * component is provided, this directive will enable Polymer's event and\n * two-way binding syntax styles.\n */\n@Directive({\n  selector: 'template'\n})\nexport class TemplateDirective {\n  ready: Promise<void>;\n\n  constructor(\n    public elementRef: ElementRef,\n    @Inject(POLYMER_HOST)\n    @Optional()\n    public polymerHost: any,\n    private zone: NgZone\n  ) {\n    this.ready = (async () => {\n      if (this.polymerHost) {\n        this.enableEventBindings(elementRef.nativeElement);\n        await this.enablePropertyBindings(elementRef.nativeElement);\n      }\n    })();\n  }\n\n  /**\n   * Enables the use of Polymer event bindings. An event binding is declared\n   * with the syntax `on-event-name=\"handler\"`, where `event-name` is the\n   * name of the event to listen to and `handler` is the name of the host's\n   * method to call when the event is dispatched.\n   *\n   * @param template the Polymer template to enable event binding syntax for\n   */\n  enableEventBindings(template: PolymerTemplate) {\n    // When templatize looks for a PropertyEffects host, it will use the\n    // template's __dataHost property. This is the _methodHost for a template\n    // instance and is used to add event listener bindings.\n    template.__dataHost = this.polymerHost;\n  }\n\n  /**\n   * Enables the use of Polymer property bindings. A property binding is\n   * declared either as a one-way binding `value=\"[[propName]]\"` or a two-way\n   * binding `value=\"{{propName}}\"`.\n   *\n   * @param template the Polymer template to enable data binding syntax for\n   */\n  async enablePropertyBindings(template: PolymerTemplate) {\n    const { hostProps } = await this.getTemplateInfo(template);\n    if (hostProps) {\n      for (let prop in hostProps) {\n        // Angular -> Polymer (one-way bindings)\n        const initialValue = this.polymerHost[prop];\n        wrapAndDefineDescriptor(this.polymerHost, prop, {\n          afterSet(changed: boolean, value: any) {\n            if (changed) {\n              template[`_host_${prop}`] = value;\n            }\n          }\n        });\n\n        this.polymerHost[prop] = initialValue;\n\n        // Polymer -> Angular (two-way bindings)\n        const eventName = `_host_${camelToDashCase(prop)}-changed`;\n        template.addEventListener(eventName, event => {\n          if (\n            !this.isSplicesChange(<CustomEvent>event) &&\n            !this.isPathChange(<CustomEvent>event)\n          ) {\n            this.zone.run(() => {\n              this.polymerHost[prop] = (<CustomEvent>event).detail.value;\n            });\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * Retrieves the template info metadata for a Polymer template.\n   *\n   * @param template the Polymer template to retrieve template info for\n   * @returns a Promise that resolves with the template's info\n   */\n  async getTemplateInfo(template: PolymerTemplate): Promise<TemplateInfo> {\n    if (template._templateInfo) {\n      return template._templateInfo;\n    } else {\n      return await whenSet(template, '_templateInfo');\n    }\n  }\n\n  /**\n   * Indicates whether or not an event is a \"splices\" Polymer change event,\n   * which has a detail value object that dictates what elements were changed if\n   * the array reference remains the same.\n   *\n   * @param event the event to check\n   * @returns true if the event is a splices change event\n   */\n  private isSplicesChange(event: CustomEvent): boolean {\n    const value = event.detail.value;\n    return value && Array.isArray(value.indexSplices);\n  }\n\n  /**\n   * Indicates whether or not an event is a path Polymer change event, which\n   * has a detail path property indicating the path of the value changed, and a\n   * value of the path's value. This is used when an array or object reference\n   * remains the same.\n   *\n   * @param event the event to check\n   * @returns true if the event is a path change event\n   */\n  private isPathChange(event: CustomEvent): boolean {\n    return typeof event.detail.path === 'string';\n  }\n}\n","import { NgModule, Provider, APP_INITIALIZER } from '@angular/core';\nimport { WebComponentsReadyModule } from '@codebakery/origami/polyfills';\nimport { shimHTMLTemplateAppend } from './shim-template-append';\nimport { TemplateDirective } from './template.directive';\n\nshimHTMLTemplateAppend();\n\nexport const TEMPLATES_READY_PROVIDER: Provider = {\n  provide: APP_INITIALIZER,\n  multi: true,\n  useValue: shimHTMLTemplateAppend\n};\n\n@NgModule({\n  imports: [WebComponentsReadyModule],\n  declarations: [TemplateDirective],\n  providers: [TEMPLATES_READY_PROVIDER],\n  exports: [TemplateDirective]\n})\nexport class TemplateModule {}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public_api';\n"],"names":[],"mappings":"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"}