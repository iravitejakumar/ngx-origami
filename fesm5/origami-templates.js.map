{"version":3,"file":"origami-templates.js","sources":["ng://@codebakery/origami/templates/src/polymerHost.ts","ng://@codebakery/origami/templates/src/shim-template-append.ts","ng://@codebakery/origami/templates/src/template.directive.ts","ng://@codebakery/origami/templates/src/template.module.ts","ng://@codebakery/origami/templates/origami-templates.ts"],"sourcesContent":["import { InjectionToken, Provider, Type } from '@angular/core';\n\n/**\n * Token that represents the Polymer host that `<template>` elements should\n * refer to for Polymer data binding. The token will be provided when using\n * `polymerHost()`.\n */\nexport const POLYMER_HOST = new InjectionToken<any>('polymerHost');\n\n/**\n * Creates a `Provider` that connects a components' Polymer `<template>`\n * elements' data binding system to the host component instance.\n *\n * This enables the use of event, one-way, and two-way Polymer data binding\n * within a `<template>` that refers to the host Angular component's methods and\n * properties.\n *\n * @param componentType the component type whose instances should be provided\n *   as the Polymer host to the instance's `<template>` elements.\n */\nexport function polymerHost(componentType: Type<any>): Provider {\n  return {\n    provide: POLYMER_HOST,\n    useFactory: patchPolymerHost,\n    deps: [componentType]\n  };\n}\n\n/**\n * Patch a data host instance with methods that are expected by Polymer's\n * `TemplateStamp` mixin. These methods are used to set up data bindings, and\n * are normally provided when a Polymer element extends from `TemplateStamp`.\n *\n * Angular components do not extend this mixin, which is why we need to patch\n * the required methods. Instances will automatically be patched when using\n * `polymerHost()`.\n *\n * @param dataHost the host to patch\n * @returns the patched dataHost\n */\nexport function patchPolymerHost(dataHost: any): any {\n  // Add methods from TemplateStamp that templatize instances expect\n  if (!dataHost._addEventListenerToNode) {\n    dataHost._addEventListenerToNode = (\n      node: Node,\n      eventName: string,\n      handler: (e: Event) => void\n    ) => {\n      node.addEventListener(eventName, handler);\n    };\n  }\n\n  return dataHost;\n}\n","import { whenSet } from '@codebakery/origami/util';\n\ndeclare global {\n  interface Window {\n    HTMLTemplateElement: typeof HTMLTemplateElement;\n  }\n}\n\nlet shimPromise: Promise<void> | undefined;\n/**\n * Angular incorrectly adds `<template>` children to the element's child node\n * list instead of its content. This shim forces children appended to a\n * `<template>` to be added to its content instead.\n *\n * https://github.com/angular/angular/issues/15557\n *\n * @returns a Promise that resolves when the HTMLTemplateElement is shimmed\n */\nexport function shimHTMLTemplateAppend(): Promise<void> {\n  if (!shimPromise) {\n    const shim = () => {\n      // Angular's renderer will add children to a <template> instead of to its\n      // content. This shim will force any children added to a <template> to be\n      // added to its content instead.\n      // https://github.com/angular/angular/issues/15557\n      const nativeAppend = HTMLTemplateElement.prototype.appendChild;\n      HTMLTemplateElement.prototype.appendChild = function<T extends Node>(\n        childNode: T\n      ) {\n        if (this.content) {\n          return this.content.appendChild(childNode);\n        } else {\n          return <T>nativeAppend.apply(this, [childNode]);\n        }\n      };\n    };\n\n    shimPromise = new Promise(async resolve => {\n      await whenSet(window, 'HTMLTemplateElement');\n      shim();\n      resolve();\n    });\n  }\n\n  return shimPromise;\n}\n\n/**\n * Resets `shimHTMLTemplateAppend()` so that it will re-shim the class next\n * time it is called. This is primarily used for testing.\n */\nexport function resetShimHTMLTemplateAppend() {\n  shimPromise = undefined;\n}\n","import { Directive, ElementRef, Inject, Optional, NgZone } from '@angular/core';\nimport { whenSet, wrapAndDefineDescriptor } from '@codebakery/origami/util';\nimport { camelToDashCase } from '@polymer/polymer/lib/utils/case-map';\nimport { TemplateInfo } from '@polymer/polymer/interfaces';\nimport { POLYMER_HOST } from './polymerHost';\n\n/**\n * An HTMLTemplateElement that is processed by Polymer's templatizer.\n */\nexport interface PolymerTemplate extends HTMLTemplateElement {\n  /**\n   * Added by the `PropertyEffects` mixin to instruct templatize of the host\n   * for the template. Effects that are not part of the template instance will\n   * propagate to this host.\n   */\n  __dataHost?: any;\n  /**\n   * Template metadata generated from `TemplateStamp`.\n   */\n  _templateInfo?: TemplateInfo;\n  /**\n   * Host properties are defined as `_host_propName` by templatizer.\n   */\n  [hostProp: string]: any;\n}\n\n/**\n * This directive is attached to each `<template>` element. If a Polymer host\n * component is provided, this directive will enable Polymer's event and\n * two-way binding syntax styles.\n */\n@Directive({\n  selector: 'template'\n})\nexport class TemplateDirective {\n  ready: Promise<void>;\n\n  constructor(\n    public elementRef: ElementRef,\n    @Inject(POLYMER_HOST)\n    @Optional()\n    public polymerHost: any,\n    private zone: NgZone\n  ) {\n    this.ready = (async () => {\n      if (this.polymerHost) {\n        this.enableEventBindings(elementRef.nativeElement);\n        await this.enablePropertyBindings(elementRef.nativeElement);\n      }\n    })();\n  }\n\n  /**\n   * Enables the use of Polymer event bindings. An event binding is declared\n   * with the syntax `on-event-name=\"handler\"`, where `event-name` is the\n   * name of the event to listen to and `handler` is the name of the host's\n   * method to call when the event is dispatched.\n   *\n   * @param template the Polymer template to enable event binding syntax for\n   */\n  enableEventBindings(template: PolymerTemplate) {\n    // When templatize looks for a PropertyEffects host, it will use the\n    // template's __dataHost property. This is the _methodHost for a template\n    // instance and is used to add event listener bindings.\n    template.__dataHost = this.polymerHost;\n  }\n\n  /**\n   * Enables the use of Polymer property bindings. A property binding is\n   * declared either as a one-way binding `value=\"[[propName]]\"` or a two-way\n   * binding `value=\"{{propName}}\"`.\n   *\n   * @param template the Polymer template to enable data binding syntax for\n   */\n  async enablePropertyBindings(template: PolymerTemplate) {\n    const { hostProps } = await this.getTemplateInfo(template);\n    if (hostProps) {\n      for (let prop in hostProps) {\n        // Angular -> Polymer (one-way bindings)\n        const initialValue = this.polymerHost[prop];\n        wrapAndDefineDescriptor(this.polymerHost, prop, {\n          afterSet(changed: boolean, value: any) {\n            if (changed) {\n              template[`_host_${prop}`] = value;\n            }\n          }\n        });\n\n        this.polymerHost[prop] = initialValue;\n\n        // Polymer -> Angular (two-way bindings)\n        const eventName = `_host_${camelToDashCase(prop)}-changed`;\n        template.addEventListener(eventName, event => {\n          if (\n            !this.isSplicesChange(<CustomEvent>event) &&\n            !this.isPathChange(<CustomEvent>event)\n          ) {\n            this.zone.run(() => {\n              this.polymerHost[prop] = (<CustomEvent>event).detail.value;\n            });\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * Retrieves the template info metadata for a Polymer template.\n   *\n   * @param template the Polymer template to retrieve template info for\n   * @returns a Promise that resolves with the template's info\n   */\n  async getTemplateInfo(template: PolymerTemplate): Promise<TemplateInfo> {\n    if (template._templateInfo) {\n      return template._templateInfo;\n    } else {\n      return await whenSet(template, '_templateInfo');\n    }\n  }\n\n  /**\n   * Indicates whether or not an event is a \"splices\" Polymer change event,\n   * which has a detail value object that dictates what elements were changed if\n   * the array reference remains the same.\n   *\n   * @param event the event to check\n   * @returns true if the event is a splices change event\n   */\n  private isSplicesChange(event: CustomEvent): boolean {\n    const value = event.detail.value;\n    return value && Array.isArray(value.indexSplices);\n  }\n\n  /**\n   * Indicates whether or not an event is a path Polymer change event, which\n   * has a detail path property indicating the path of the value changed, and a\n   * value of the path's value. This is used when an array or object reference\n   * remains the same.\n   *\n   * @param event the event to check\n   * @returns true if the event is a path change event\n   */\n  private isPathChange(event: CustomEvent): boolean {\n    return typeof event.detail.path === 'string';\n  }\n}\n","import { NgModule, Provider, APP_INITIALIZER } from '@angular/core';\nimport { WebComponentsReadyModule } from '@codebakery/origami/polyfills';\nimport { shimHTMLTemplateAppend } from './shim-template-append';\nimport { TemplateDirective } from './template.directive';\n\nshimHTMLTemplateAppend();\n\nexport const TEMPLATES_READY_PROVIDER: Provider = {\n  provide: APP_INITIALIZER,\n  multi: true,\n  useValue: shimHTMLTemplateAppend\n};\n\n@NgModule({\n  imports: [WebComponentsReadyModule],\n  declarations: [TemplateDirective],\n  providers: [TEMPLATES_READY_PROVIDER],\n  exports: [TemplateDirective]\n})\nexport class TemplateModule {}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public_api';\n"],"names":[],"mappings":"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"}