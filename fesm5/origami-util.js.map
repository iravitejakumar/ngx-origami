{"version":3,"file":"origami-util.js","sources":["ng://@codebakery/origami/util/src/descriptors.ts","ng://@codebakery/origami/util/src/when-set.ts","ng://@codebakery/origami/util/origami-util.ts"],"sourcesContent":["/**\n * Descriptor hooks that can be injected into a property's getter and setter.\n */\nexport interface DescriptorHooks<T> {\n  /**\n   * Executes before a property's value is set. If this function returns true,\n   * the property will be set. Otherwise, the property will not be updated.\n   *\n   * @param value the value requested to set\n   * @returns true if the property should be set, otherwise false\n   */\n  shouldSet?(value: T): boolean;\n  /**\n   * Executes before a property's value is set and after any `shouldSet()` has\n   * returned true. This allows the value to be manipulated before setting it.\n   *\n   * @param value the value requested to set\n   * @returns the value to actually set\n   */\n  beforeSet?(value: T): T;\n  /**\n   * Executes after a property's value is set. This allows side effects to be\n   * performed on the new value or to determine if a value changed.\n   *\n   * @param changed indicates whether or not the value changed\n   * @param current the new value\n   * @param previous the previous value\n   */\n  afterSet?(changed: boolean, current: T, previous: T): void;\n}\n\n/**\n * Redefines an object's property with descriptor hooks that inject side effects\n * into the property's getter and setter. If the property has an existing\n * getter or setter, they will be preserved.\n *\n * @param target the object target for the descriptor\n * @param propertyKey the property of the object target\n * @param hooks the hooks to inject\n */\nexport function wrapAndDefineDescriptor<T>(\n  target: any,\n  propertyKey: string,\n  hooks: DescriptorHooks<T>\n) {\n  const desc = wrapDescriptor(target, propertyKey, hooks);\n  Object.defineProperty(target, propertyKey, desc);\n}\n\n/**\n * Creates a property descriptor that injects hooks into a property's getter and\n * setter to execute side effects.\n *\n * @param target the object target for the descriptor\n * @param propertyKey the property of the object target\n * @param hooks the hooks to inject\n * @returns a descriptor that can be used in `Object.defineProperty()`\n */\nexport function wrapDescriptor<T>(\n  target: any,\n  propertyKey: PropertyKey,\n  hooks: DescriptorHooks<T>\n): PropertyDescriptor {\n  const desc = getPropertyDescriptor(target, propertyKey);\n  const properties = new WeakMap();\n  return {\n    enumerable: desc ? desc.enumerable : true,\n    get() {\n      if (desc && desc.get) {\n        return desc.get.apply(this);\n      } else {\n        const props = properties.get(this);\n        return props && props[propertyKey];\n      }\n    },\n    set(original: T) {\n      let value = original;\n      if (!hooks.shouldSet || hooks.shouldSet.apply(this, [value])) {\n        if (hooks.beforeSet) {\n          value = hooks.beforeSet.apply(this, [value]);\n        }\n\n        let props = properties.get(this);\n        if (!props) {\n          props = {};\n          properties.set(this, props);\n        }\n\n        const changed = value !== props[propertyKey];\n        props[propertyKey] = value;\n        if (desc && desc.set) {\n          desc.set.apply(this, [value]);\n        }\n\n        if (hooks.afterSet) {\n          hooks.afterSet.apply(this, [changed, value, original]);\n        }\n      }\n    }\n  };\n}\n\n/**\n * Similar to `Object.getOwnPropertyDescriptor()`, but this function will\n * search through the target's prototype chain when looking for the property's\n * descriptor.\n *\n * @param target object that contains the property\n * @param propertyKey name of the property\n * @returns the property descriptor if one exists\n */\nexport function getPropertyDescriptor(\n  target: any,\n  propertyKey: PropertyKey\n): PropertyDescriptor | undefined {\n  while (target) {\n    const desc = Object.getOwnPropertyDescriptor(target, propertyKey);\n    if (desc) {\n      return desc;\n    } else {\n      target = Object.getPrototypeOf(target);\n    }\n  }\n}\n","/**\n * Map of targets, their properties, and promises that will be resolved when\n * they are set. This allows multiple invocations to `whenSet()` for the same\n * target and property to resolve.\n */\nlet whenSetMap: WeakMap<any, Map<PropertyKey, Promise<any>>>;\nlet callbackSyncMap: WeakMap<Promise<any>, Array<(value: any) => void>>;\n\n/**\n * Resolves when the provided property is set to a non-undefined value on the\n * target.\n *\n * @param target the target to listen to\n * @param property the property to wait for\n * @param predicate the predicate to determine whether or not the Promise\n *   should resolve for a new value. The default is to check if the value is\n *   not undefined.\n * @param callbackSync if more precise timing is needed, this callback may be\n *   provided to immediately process the set value since the resolved Promise\n *   will be async\n * @returns a Promise that resolves with the new value\n */\nexport function whenSet<\n  T,\n  K extends keyof T,\n  V extends T[K] = Exclude<T[K], undefined>\n>(\n  target: T,\n  property: K,\n  predicate = (value: any) => typeof value !== 'undefined',\n  callbackSync?: (value: V) => void\n): Promise<V> {\n  let currentValue = target[property];\n  if (predicate(currentValue)) {\n    if (typeof callbackSync === 'function') {\n      callbackSync(<V>target[property]);\n    }\n\n    return Promise.resolve(<V>target[property]);\n  } else {\n    if (!whenSetMap) {\n      whenSetMap = new WeakMap();\n    }\n\n    if (!callbackSyncMap) {\n      callbackSyncMap = new WeakMap();\n    }\n\n    let propertyPromiseMap: Map<K, Promise<V>>;\n    if (!whenSetMap.has(target)) {\n      propertyPromiseMap = new Map();\n      whenSetMap.set(target, propertyPromiseMap);\n    } else {\n      propertyPromiseMap = <Map<K, Promise<V>>>whenSetMap.get(target);\n    }\n\n    if (propertyPromiseMap.has(property)) {\n      const promise = propertyPromiseMap.get(property)!;\n      if (typeof callbackSync === 'function') {\n        const callbacks = callbackSyncMap.get(promise)!;\n        callbacks.push(callbackSync);\n      }\n\n      return promise;\n    } else {\n      const promise = new Promise<V>(resolve => {\n        Object.defineProperty(target, property, {\n          configurable: true,\n          enumerable: true,\n          get() {\n            return currentValue;\n          },\n          set(value: V) {\n            currentValue = value;\n            if (predicate(value)) {\n              Object.defineProperty(target, property, {\n                value,\n                configurable: true,\n                enumerable: true,\n                writable: true\n              });\n\n              propertyPromiseMap.delete(property);\n              if (!propertyPromiseMap.size) {\n                whenSetMap.delete(target);\n              }\n\n              const callbacks = callbackSyncMap.get(promise)!;\n              callbacks.forEach(callback => {\n                callback(value);\n              });\n\n              resolve(value);\n            }\n          }\n        });\n      });\n\n      propertyPromiseMap.set(property, promise);\n      const callbacks: Array<(value: V) => void> = [];\n      if (typeof callbackSync === 'function') {\n        callbacks.push(callbackSync);\n      }\n\n      callbackSyncMap.set(promise, callbacks);\n      return promise;\n    }\n  }\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public_api';\n"],"names":[],"mappings":"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"}