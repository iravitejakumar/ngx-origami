{"version":3,"file":"origami-util.umd.js","sources":["ng://@codebakery/origami/util/src/descriptors.ts","ng://@codebakery/origami/util/src/when-set.ts"],"sourcesContent":["/**\n * Descriptor hooks that can be injected into a property's getter and setter.\n */\nexport interface DescriptorHooks<T> {\n  /**\n   * Executes before a property's value is set. If this function returns true,\n   * the property will be set. Otherwise, the property will not be updated.\n   *\n   * @param value the value requested to set\n   * @returns true if the property should be set, otherwise false\n   */\n  shouldSet?(value: T): boolean;\n  /**\n   * Executes before a property's value is set and after any `shouldSet()` has\n   * returned true. This allows the value to be manipulated before setting it.\n   *\n   * @param value the value requested to set\n   * @returns the value to actually set\n   */\n  beforeSet?(value: T): T;\n  /**\n   * Executes after a property's value is set. This allows side effects to be\n   * performed on the new value or to determine if a value changed.\n   *\n   * @param changed indicates whether or not the value changed\n   * @param current the new value\n   * @param previous the previous value\n   */\n  afterSet?(changed: boolean, current: T, previous: T): void;\n}\n\n/**\n * Redefines an object's property with descriptor hooks that inject side effects\n * into the property's getter and setter. If the property has an existing\n * getter or setter, they will be preserved.\n *\n * @param target the object target for the descriptor\n * @param propertyKey the property of the object target\n * @param hooks the hooks to inject\n */\nexport function wrapAndDefineDescriptor<T>(\n  target: any,\n  propertyKey: string,\n  hooks: DescriptorHooks<T>\n) {\n  const desc = wrapDescriptor(target, propertyKey, hooks);\n  Object.defineProperty(target, propertyKey, desc);\n}\n\n/**\n * Creates a property descriptor that injects hooks into a property's getter and\n * setter to execute side effects.\n *\n * @param target the object target for the descriptor\n * @param propertyKey the property of the object target\n * @param hooks the hooks to inject\n * @returns a descriptor that can be used in `Object.defineProperty()`\n */\nexport function wrapDescriptor<T>(\n  target: any,\n  propertyKey: PropertyKey,\n  hooks: DescriptorHooks<T>\n): PropertyDescriptor {\n  const desc = getPropertyDescriptor(target, propertyKey);\n  const properties = new WeakMap();\n  return {\n    enumerable: desc ? desc.enumerable : true,\n    get() {\n      if (desc && desc.get) {\n        return desc.get.apply(this);\n      } else {\n        const props = properties.get(this);\n        return props && props[propertyKey];\n      }\n    },\n    set(original: T) {\n      let value = original;\n      if (!hooks.shouldSet || hooks.shouldSet.apply(this, [value])) {\n        if (hooks.beforeSet) {\n          value = hooks.beforeSet.apply(this, [value]);\n        }\n\n        let props = properties.get(this);\n        if (!props) {\n          props = {};\n          properties.set(this, props);\n        }\n\n        const changed = value !== props[propertyKey];\n        props[propertyKey] = value;\n        if (desc && desc.set) {\n          desc.set.apply(this, [value]);\n        }\n\n        if (hooks.afterSet) {\n          hooks.afterSet.apply(this, [changed, value, original]);\n        }\n      }\n    }\n  };\n}\n\n/**\n * Similar to `Object.getOwnPropertyDescriptor()`, but this function will\n * search through the target's prototype chain when looking for the property's\n * descriptor.\n *\n * @param target object that contains the property\n * @param propertyKey name of the property\n * @returns the property descriptor if one exists\n */\nexport function getPropertyDescriptor(\n  target: any,\n  propertyKey: PropertyKey\n): PropertyDescriptor | undefined {\n  while (target) {\n    const desc = Object.getOwnPropertyDescriptor(target, propertyKey);\n    if (desc) {\n      return desc;\n    } else {\n      target = Object.getPrototypeOf(target);\n    }\n  }\n}\n","/**\n * Map of targets, their properties, and promises that will be resolved when\n * they are set. This allows multiple invocations to `whenSet()` for the same\n * target and property to resolve.\n */\nlet whenSetMap: WeakMap<any, Map<PropertyKey, Promise<any>>>;\nlet callbackSyncMap: WeakMap<Promise<any>, Array<(value: any) => void>>;\n\n/**\n * Resolves when the provided property is set to a non-undefined value on the\n * target.\n *\n * @param target the target to listen to\n * @param property the property to wait for\n * @param predicate the predicate to determine whether or not the Promise\n *   should resolve for a new value. The default is to check if the value is\n *   not undefined.\n * @param callbackSync if more precise timing is needed, this callback may be\n *   provided to immediately process the set value since the resolved Promise\n *   will be async\n * @returns a Promise that resolves with the new value\n */\nexport function whenSet<\n  T,\n  K extends keyof T,\n  V extends T[K] = Exclude<T[K], undefined>\n>(\n  target: T,\n  property: K,\n  predicate = (value: any) => typeof value !== 'undefined',\n  callbackSync?: (value: V) => void\n): Promise<V> {\n  let currentValue = target[property];\n  if (predicate(currentValue)) {\n    if (typeof callbackSync === 'function') {\n      callbackSync(<V>target[property]);\n    }\n\n    return Promise.resolve(<V>target[property]);\n  } else {\n    if (!whenSetMap) {\n      whenSetMap = new WeakMap();\n    }\n\n    if (!callbackSyncMap) {\n      callbackSyncMap = new WeakMap();\n    }\n\n    let propertyPromiseMap: Map<K, Promise<V>>;\n    if (!whenSetMap.has(target)) {\n      propertyPromiseMap = new Map();\n      whenSetMap.set(target, propertyPromiseMap);\n    } else {\n      propertyPromiseMap = <Map<K, Promise<V>>>whenSetMap.get(target);\n    }\n\n    if (propertyPromiseMap.has(property)) {\n      const promise = propertyPromiseMap.get(property)!;\n      if (typeof callbackSync === 'function') {\n        const callbacks = callbackSyncMap.get(promise)!;\n        callbacks.push(callbackSync);\n      }\n\n      return promise;\n    } else {\n      const promise = new Promise<V>(resolve => {\n        Object.defineProperty(target, property, {\n          configurable: true,\n          enumerable: true,\n          get() {\n            return currentValue;\n          },\n          set(value: V) {\n            currentValue = value;\n            if (predicate(value)) {\n              Object.defineProperty(target, property, {\n                value,\n                configurable: true,\n                enumerable: true,\n                writable: true\n              });\n\n              propertyPromiseMap.delete(property);\n              if (!propertyPromiseMap.size) {\n                whenSetMap.delete(target);\n              }\n\n              const callbacks = callbackSyncMap.get(promise)!;\n              callbacks.forEach(callback => {\n                callback(value);\n              });\n\n              resolve(value);\n            }\n          }\n        });\n      });\n\n      propertyPromiseMap.set(property, promise);\n      const callbacks: Array<(value: V) => void> = [];\n      if (typeof callbackSync === 'function') {\n        callbacks.push(callbackSync);\n      }\n\n      callbackSyncMap.set(promise, callbacks);\n      return promise;\n    }\n  }\n}\n"],"names":[],"mappings":"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"}