{"version":3,"sources":["ng://@codebakery/origami/util/src/descriptors.ts","ng://@codebakery/origami/util/src/when-set.ts"],"names":["wrapDescriptor","target","propertyKey","hooks","desc","getPropertyDescriptor","properties","WeakMap","enumerable","get","apply","this","props","set","original","value","shouldSet","beforeSet","changed","afterSet","Object","getOwnPropertyDescriptor","getPrototypeOf","whenSetMap","callbackSyncMap","property","predicate","callbackSync","propertyPromiseMap_1","currentValue","Promise","resolve","has","Map","promise","callbacks","push","promise_1","defineProperty","configurable","writable","delete","size","forEach","callback"],"mappings":"uUA0DgBA,EACdC,EACAC,EACAC,GAEA,IAAMC,EAAOC,EAAsBJ,EAAQC,GACrCI,EAAa,IAAIC,QACvB,MAAO,CACLC,YAAYJ,GAAOA,EAAKI,WACxBC,IAAG,WACD,GAAIL,GAAQA,EAAKK,IACf,OAAOL,EAAKK,IAAIC,MAAMC,MAEtB,IAAMC,EAAQN,EAAWG,IAAIE,MAC7B,OAAOC,GAASA,EAAMV,IAG1BW,IAAA,SAAIC,GACF,IAAIC,EAAQD,EACZ,IAAKX,EAAMa,WAAab,EAAMa,UAAUN,MAAMC,KAAM,CAACI,IAAS,CACxDZ,EAAMc,YACRF,EAAQZ,EAAMc,UAAUP,MAAMC,KAAM,CAACI,KAGvC,IAAIH,EAAQN,EAAWG,IAAIE,MACtBC,IACHA,EAAQ,GACRN,EAAWO,IAAIF,KAAMC,IAGvB,IAAMM,EAAUH,IAAUH,EAAMV,GAChCU,EAAMV,GAAea,EACjBX,GAAQA,EAAKS,KACfT,EAAKS,IAAIH,MAAMC,KAAM,CAACI,IAGpBZ,EAAMgB,UACRhB,EAAMgB,SAAST,MAAMC,KAAM,CAACO,EAASH,EAAOD,gBAgBtCT,EACdJ,EACAC,GAEA,KAAOD,GAAQ,CACb,IAAMG,EAAOgB,OAAOC,yBAAyBpB,EAAQC,GACrD,GAAIE,EACF,OAAOA,EAEPH,EAASmB,OAAOE,eAAerB,ICnHrC,IAAIsB,EACAC,+CAqBFvB,EACAwB,EACAC,EACAC,QADA,IAAAD,IAAAA,EAAA,SAAaX,GAAe,YAAiB,IAAVA,IAGnC,IAgBMa,EAhBFC,EAAe5B,EAAOwB,GAC1B,GAAIC,EAAUG,GAKZ,MAJ4B,mBAAjBF,GACTA,EAAgB1B,EAAOwB,IAGlBK,QAAQC,QAAW9B,EAAOwB,IAkBjC,GAhBKF,IACHA,EAAa,IAAIhB,SAGdiB,IACHA,EAAkB,IAAIjB,SAInBgB,EAAWS,IAAI/B,GAIlB2B,EAAyCL,EAAWd,IAAIR,IAHxD2B,EAAqB,IAAIK,IACzBV,EAAWV,IAAIZ,EAAQ2B,IAKrBA,EAAmBI,IAAIP,GAAW,CACpC,IAAMS,EAAUN,EAAmBnB,IAAIgB,GACvC,GAA4B,mBAAjBE,GACHQ,EAAYX,EAAgBf,IAAIyB,IAC5BE,KAAKT,GAGjB,OAAOO,EAEP,IAAMG,EAAU,IAAIP,SAAW,SAAAC,GAC7BX,OAAOkB,eAAerC,EAAQwB,EAAU,CACtCc,cAAc,EACd/B,YAAY,EACZC,IAAG,WACD,OAAOoB,GAEThB,IAAA,SAAIE,IACFc,EAAed,EACXW,EAAUX,MACZK,OAAOkB,eAAerC,EAAQwB,EAAU,CACtCV,MAAKA,EACLwB,cAAc,EACd/B,YAAY,EACZgC,UAAU,IAGZZ,EAAmBa,OAAOhB,GACrBG,EAAmBc,MACtBnB,EAAWkB,OAAOxC,GAGFuB,EAAgBf,IAAI4B,GAC5BM,SAAQ,SAAAC,GAChBA,EAAS7B,MAGXgB,EAAQhB,UAMhBa,EAAmBf,IAAIY,EAAUY,GACjC,IAAMF,EAAuC,GAM7C,MAL4B,mBAAjBR,GACTQ,EAAUC,KAAKT,GAGjBH,EAAgBX,IAAIwB,EAASF,GACtBE,sCDhEXpC,EACAC,EACAC,GAEA,IAAMC,EAAOJ,EAAeC,EAAQC,EAAaC,GACjDiB,OAAOkB,eAAerC,EAAQC,EAAaE","sourcesContent":["/**\n * Descriptor hooks that can be injected into a property's getter and setter.\n */\nexport interface DescriptorHooks<T> {\n  /**\n   * Executes before a property's value is set. If this function returns true,\n   * the property will be set. Otherwise, the property will not be updated.\n   *\n   * @param value the value requested to set\n   * @returns true if the property should be set, otherwise false\n   */\n  shouldSet?(value: T): boolean;\n  /**\n   * Executes before a property's value is set and after any `shouldSet()` has\n   * returned true. This allows the value to be manipulated before setting it.\n   *\n   * @param value the value requested to set\n   * @returns the value to actually set\n   */\n  beforeSet?(value: T): T;\n  /**\n   * Executes after a property's value is set. This allows side effects to be\n   * performed on the new value or to determine if a value changed.\n   *\n   * @param changed indicates whether or not the value changed\n   * @param current the new value\n   * @param previous the previous value\n   */\n  afterSet?(changed: boolean, current: T, previous: T): void;\n}\n\n/**\n * Redefines an object's property with descriptor hooks that inject side effects\n * into the property's getter and setter. If the property has an existing\n * getter or setter, they will be preserved.\n *\n * @param target the object target for the descriptor\n * @param propertyKey the property of the object target\n * @param hooks the hooks to inject\n */\nexport function wrapAndDefineDescriptor<T>(\n  target: any,\n  propertyKey: string,\n  hooks: DescriptorHooks<T>\n) {\n  const desc = wrapDescriptor(target, propertyKey, hooks);\n  Object.defineProperty(target, propertyKey, desc);\n}\n\n/**\n * Creates a property descriptor that injects hooks into a property's getter and\n * setter to execute side effects.\n *\n * @param target the object target for the descriptor\n * @param propertyKey the property of the object target\n * @param hooks the hooks to inject\n * @returns a descriptor that can be used in `Object.defineProperty()`\n */\nexport function wrapDescriptor<T>(\n  target: any,\n  propertyKey: PropertyKey,\n  hooks: DescriptorHooks<T>\n): PropertyDescriptor {\n  const desc = getPropertyDescriptor(target, propertyKey);\n  const properties = new WeakMap();\n  return {\n    enumerable: desc ? desc.enumerable : true,\n    get() {\n      if (desc && desc.get) {\n        return desc.get.apply(this);\n      } else {\n        const props = properties.get(this);\n        return props && props[propertyKey];\n      }\n    },\n    set(original: T) {\n      let value = original;\n      if (!hooks.shouldSet || hooks.shouldSet.apply(this, [value])) {\n        if (hooks.beforeSet) {\n          value = hooks.beforeSet.apply(this, [value]);\n        }\n\n        let props = properties.get(this);\n        if (!props) {\n          props = {};\n          properties.set(this, props);\n        }\n\n        const changed = value !== props[propertyKey];\n        props[propertyKey] = value;\n        if (desc && desc.set) {\n          desc.set.apply(this, [value]);\n        }\n\n        if (hooks.afterSet) {\n          hooks.afterSet.apply(this, [changed, value, original]);\n        }\n      }\n    }\n  };\n}\n\n/**\n * Similar to `Object.getOwnPropertyDescriptor()`, but this function will\n * search through the target's prototype chain when looking for the property's\n * descriptor.\n *\n * @param target object that contains the property\n * @param propertyKey name of the property\n * @returns the property descriptor if one exists\n */\nexport function getPropertyDescriptor(\n  target: any,\n  propertyKey: PropertyKey\n): PropertyDescriptor | undefined {\n  while (target) {\n    const desc = Object.getOwnPropertyDescriptor(target, propertyKey);\n    if (desc) {\n      return desc;\n    } else {\n      target = Object.getPrototypeOf(target);\n    }\n  }\n}\n","/**\n * Map of targets, their properties, and promises that will be resolved when\n * they are set. This allows multiple invocations to `whenSet()` for the same\n * target and property to resolve.\n */\nlet whenSetMap: WeakMap<any, Map<PropertyKey, Promise<any>>>;\nlet callbackSyncMap: WeakMap<Promise<any>, Array<(value: any) => void>>;\n\n/**\n * Resolves when the provided property is set to a non-undefined value on the\n * target.\n *\n * @param target the target to listen to\n * @param property the property to wait for\n * @param predicate the predicate to determine whether or not the Promise\n *   should resolve for a new value. The default is to check if the value is\n *   not undefined.\n * @param callbackSync if more precise timing is needed, this callback may be\n *   provided to immediately process the set value since the resolved Promise\n *   will be async\n * @returns a Promise that resolves with the new value\n */\nexport function whenSet<\n  T,\n  K extends keyof T,\n  V extends T[K] = Exclude<T[K], undefined>\n>(\n  target: T,\n  property: K,\n  predicate = (value: any) => typeof value !== 'undefined',\n  callbackSync?: (value: V) => void\n): Promise<V> {\n  let currentValue = target[property];\n  if (predicate(currentValue)) {\n    if (typeof callbackSync === 'function') {\n      callbackSync(<V>target[property]);\n    }\n\n    return Promise.resolve(<V>target[property]);\n  } else {\n    if (!whenSetMap) {\n      whenSetMap = new WeakMap();\n    }\n\n    if (!callbackSyncMap) {\n      callbackSyncMap = new WeakMap();\n    }\n\n    let propertyPromiseMap: Map<K, Promise<V>>;\n    if (!whenSetMap.has(target)) {\n      propertyPromiseMap = new Map();\n      whenSetMap.set(target, propertyPromiseMap);\n    } else {\n      propertyPromiseMap = <Map<K, Promise<V>>>whenSetMap.get(target);\n    }\n\n    if (propertyPromiseMap.has(property)) {\n      const promise = propertyPromiseMap.get(property)!;\n      if (typeof callbackSync === 'function') {\n        const callbacks = callbackSyncMap.get(promise)!;\n        callbacks.push(callbackSync);\n      }\n\n      return promise;\n    } else {\n      const promise = new Promise<V>(resolve => {\n        Object.defineProperty(target, property, {\n          configurable: true,\n          enumerable: true,\n          get() {\n            return currentValue;\n          },\n          set(value: V) {\n            currentValue = value;\n            if (predicate(value)) {\n              Object.defineProperty(target, property, {\n                value,\n                configurable: true,\n                enumerable: true,\n                writable: true\n              });\n\n              propertyPromiseMap.delete(property);\n              if (!propertyPromiseMap.size) {\n                whenSetMap.delete(target);\n              }\n\n              const callbacks = callbackSyncMap.get(promise)!;\n              callbacks.forEach(callback => {\n                callback(value);\n              });\n\n              resolve(value);\n            }\n          }\n        });\n      });\n\n      propertyPromiseMap.set(property, promise);\n      const callbacks: Array<(value: V) => void> = [];\n      if (typeof callbackSync === 'function') {\n        callbacks.push(callbackSync);\n      }\n\n      callbackSyncMap.set(promise, callbacks);\n      return promise;\n    }\n  }\n}\n"]}