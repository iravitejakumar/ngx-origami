import { InjectionToken } from '@angular/core';
/**
 * Token that represents the Polymer host that `<template>` elements should
 * refer to for Polymer data binding. The token will be provided when using
 * `polymerHost()`.
 */
export const POLYMER_HOST = new InjectionToken('polymerHost');
/**
 * Creates a `Provider` that connects a components' Polymer `<template>`
 * elements' data binding system to the host component instance.
 *
 * This enables the use of event, one-way, and two-way Polymer data binding
 * within a `<template>` that refers to the host Angular component's methods and
 * properties.
 *
 * @param componentType the component type whose instances should be provided
 *   as the Polymer host to the instance's `<template>` elements.
 */
export function polymerHost(componentType) {
    return {
        provide: POLYMER_HOST,
        useFactory: patchPolymerHost,
        deps: [componentType]
    };
}
/**
 * Patch a data host instance with methods that are expected by Polymer's
 * `TemplateStamp` mixin. These methods are used to set up data bindings, and
 * are normally provided when a Polymer element extends from `TemplateStamp`.
 *
 * Angular components do not extend this mixin, which is why we need to patch
 * the required methods. Instances will automatically be patched when using
 * `polymerHost()`.
 *
 * @param dataHost the host to patch
 * @returns the patched dataHost
 */
export function patchPolymerHost(dataHost) {
    // Add methods from TemplateStamp that templatize instances expect
    if (!dataHost._addEventListenerToNode) {
        dataHost._addEventListenerToNode = (node, eventName, handler) => {
            node.addEventListener(eventName, handler);
        };
    }
    return dataHost;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9seW1lckhvc3QuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtb3JpZ2FtaS90ZW1wbGF0ZXMvIiwic291cmNlcyI6WyJzcmMvcG9seW1lckhvc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGNBQWMsRUFBa0IsTUFBTSxlQUFlLENBQUM7QUFFL0Q7Ozs7R0FJRztBQUNILE1BQU0sQ0FBQyxNQUFNLFlBQVksR0FBRyxJQUFJLGNBQWMsQ0FBTSxhQUFhLENBQUMsQ0FBQztBQUVuRTs7Ozs7Ozs7OztHQVVHO0FBQ0gsTUFBTSxVQUFVLFdBQVcsQ0FBQyxhQUF3QjtJQUNsRCxPQUFPO1FBQ0wsT0FBTyxFQUFFLFlBQVk7UUFDckIsVUFBVSxFQUFFLGdCQUFnQjtRQUM1QixJQUFJLEVBQUUsQ0FBQyxhQUFhLENBQUM7S0FDdEIsQ0FBQztBQUNKLENBQUM7QUFFRDs7Ozs7Ozs7Ozs7R0FXRztBQUNILE1BQU0sVUFBVSxnQkFBZ0IsQ0FBQyxRQUFhO0lBQzVDLGtFQUFrRTtJQUNsRSxJQUFJLENBQUMsUUFBUSxDQUFDLHVCQUF1QixFQUFFO1FBQ3JDLFFBQVEsQ0FBQyx1QkFBdUIsR0FBRyxDQUNqQyxJQUFVLEVBQ1YsU0FBaUIsRUFDakIsT0FBMkIsRUFDM0IsRUFBRTtZQUNGLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDNUMsQ0FBQyxDQUFDO0tBQ0g7SUFFRCxPQUFPLFFBQVEsQ0FBQztBQUNsQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0aW9uVG9rZW4sIFByb3ZpZGVyLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8qKlxuICogVG9rZW4gdGhhdCByZXByZXNlbnRzIHRoZSBQb2x5bWVyIGhvc3QgdGhhdCBgPHRlbXBsYXRlPmAgZWxlbWVudHMgc2hvdWxkXG4gKiByZWZlciB0byBmb3IgUG9seW1lciBkYXRhIGJpbmRpbmcuIFRoZSB0b2tlbiB3aWxsIGJlIHByb3ZpZGVkIHdoZW4gdXNpbmdcbiAqIGBwb2x5bWVySG9zdCgpYC5cbiAqL1xuZXhwb3J0IGNvbnN0IFBPTFlNRVJfSE9TVCA9IG5ldyBJbmplY3Rpb25Ub2tlbjxhbnk+KCdwb2x5bWVySG9zdCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgUHJvdmlkZXJgIHRoYXQgY29ubmVjdHMgYSBjb21wb25lbnRzJyBQb2x5bWVyIGA8dGVtcGxhdGU+YFxuICogZWxlbWVudHMnIGRhdGEgYmluZGluZyBzeXN0ZW0gdG8gdGhlIGhvc3QgY29tcG9uZW50IGluc3RhbmNlLlxuICpcbiAqIFRoaXMgZW5hYmxlcyB0aGUgdXNlIG9mIGV2ZW50LCBvbmUtd2F5LCBhbmQgdHdvLXdheSBQb2x5bWVyIGRhdGEgYmluZGluZ1xuICogd2l0aGluIGEgYDx0ZW1wbGF0ZT5gIHRoYXQgcmVmZXJzIHRvIHRoZSBob3N0IEFuZ3VsYXIgY29tcG9uZW50J3MgbWV0aG9kcyBhbmRcbiAqIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudFR5cGUgdGhlIGNvbXBvbmVudCB0eXBlIHdob3NlIGluc3RhbmNlcyBzaG91bGQgYmUgcHJvdmlkZWRcbiAqICAgYXMgdGhlIFBvbHltZXIgaG9zdCB0byB0aGUgaW5zdGFuY2UncyBgPHRlbXBsYXRlPmAgZWxlbWVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb2x5bWVySG9zdChjb21wb25lbnRUeXBlOiBUeXBlPGFueT4pOiBQcm92aWRlciB7XG4gIHJldHVybiB7XG4gICAgcHJvdmlkZTogUE9MWU1FUl9IT1NULFxuICAgIHVzZUZhY3Rvcnk6IHBhdGNoUG9seW1lckhvc3QsXG4gICAgZGVwczogW2NvbXBvbmVudFR5cGVdXG4gIH07XG59XG5cbi8qKlxuICogUGF0Y2ggYSBkYXRhIGhvc3QgaW5zdGFuY2Ugd2l0aCBtZXRob2RzIHRoYXQgYXJlIGV4cGVjdGVkIGJ5IFBvbHltZXInc1xuICogYFRlbXBsYXRlU3RhbXBgIG1peGluLiBUaGVzZSBtZXRob2RzIGFyZSB1c2VkIHRvIHNldCB1cCBkYXRhIGJpbmRpbmdzLCBhbmRcbiAqIGFyZSBub3JtYWxseSBwcm92aWRlZCB3aGVuIGEgUG9seW1lciBlbGVtZW50IGV4dGVuZHMgZnJvbSBgVGVtcGxhdGVTdGFtcGAuXG4gKlxuICogQW5ndWxhciBjb21wb25lbnRzIGRvIG5vdCBleHRlbmQgdGhpcyBtaXhpbiwgd2hpY2ggaXMgd2h5IHdlIG5lZWQgdG8gcGF0Y2hcbiAqIHRoZSByZXF1aXJlZCBtZXRob2RzLiBJbnN0YW5jZXMgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIHBhdGNoZWQgd2hlbiB1c2luZ1xuICogYHBvbHltZXJIb3N0KClgLlxuICpcbiAqIEBwYXJhbSBkYXRhSG9zdCB0aGUgaG9zdCB0byBwYXRjaFxuICogQHJldHVybnMgdGhlIHBhdGNoZWQgZGF0YUhvc3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhdGNoUG9seW1lckhvc3QoZGF0YUhvc3Q6IGFueSk6IGFueSB7XG4gIC8vIEFkZCBtZXRob2RzIGZyb20gVGVtcGxhdGVTdGFtcCB0aGF0IHRlbXBsYXRpemUgaW5zdGFuY2VzIGV4cGVjdFxuICBpZiAoIWRhdGFIb3N0Ll9hZGRFdmVudExpc3RlbmVyVG9Ob2RlKSB7XG4gICAgZGF0YUhvc3QuX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUgPSAoXG4gICAgICBub2RlOiBOb2RlLFxuICAgICAgZXZlbnROYW1lOiBzdHJpbmcsXG4gICAgICBoYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgICApID0+IHtcbiAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZGF0YUhvc3Q7XG59XG4iXX0=